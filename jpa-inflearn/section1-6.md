---
typora-root-url: C:\Record\jpa-inflearn
---

# JPA 소개



### SQL 중심적인 개발의 문제점

- 반복적인 CRUD(SQL) 작성
- 객체 지향과 관계형 데이터베이스의 패러다임 불일치
  - 상속, 연관관계, 데이터 타입, 데이터 식별 방법 차이
- 객체 그래프 탐색
- 엔티티 신뢰 문제
- 모든 객체를 미리 로딩할 수는 없다. -> 지연로딩
- 비교하기 - 자바 컬렉션에서 조회



### JPA 소개

Java Persistence API 자바 진영의 ORM 기술 표준

[JPA 명세](https://www.oracle.com/java/technologies/persistence-jsp.html)



ORM?

- 객체 관계 매핑
- 객체와 관계형 DB 모델들을 ORM 프레임워크가 중간에서 매핑



JPA 는 애플리케이션과 JDBC 사이에서 동작

![course1-1](/image/course1-1.PNG)



JPA 는 표준 명세

- JPA 는 인터페이스의 모음
- JPA 2.1 표준 명세를 구현한 3가지 구현체
- 하이버네이트, EclipseLink, DataNuclesus



JPA 사용해야 하는 이유?

- SQL 중심적인 개발에서 객체 중심 개발
- 생산성
- 유지보수
- 패러다임의 불일치 해결



JPA 성능 최적화 기능

##### 1차 캐시와 동일성 보장

- 같은 트랜잭션 안에서 같은 엔티티회를 반환 - 약간의 조회 성능 향상
- DB Isolation Level 이 Read Commit 이어도 애플리케이션에서 Repeatable Read 보장



TODO: Isolation Level 조사



##### 트랜잭션을 지원하는 쓰기 지연 = 버퍼링 기능

- 트랜잭션 커밋 전까지 INSERT SQL 모음
- JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송

##### 

##### 지연 로딩과 즉시 로딩





## JPA 시작하기

- H2 DB 설치
- JPA 하이버네이트



데이터베이스 방언

- JPA 는 특정 데이터베이스에 종속 X
- 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름
  - 가변문자 MySQL VARCHAR Oracle VARCHAR2
  - 문자열 자르는 함수: SQL 표준 SUBSTRING(), Oracle SUBSTR()
  - 페이징: MySQL LIMIT, Oracle ROWNUM

### Hello JPA - 프로젝트 생성

### Hello JPA - 애플리케이션 개발



## 영속성 관리 - 내부 동작 방식



### 영속성 컨텍스트 1

영속성 컨텍스트 

- 엔티티를 영구 저장하는 환경
- 논리적인 개념
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근



엔티티의 생명주기

- 비영속 : 영속성 컨텍스트와 관계가 없는 새로운 상태
- 영속: 영속성 컨텍스트에 관리되는 상태
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 삭제된 상태



영속성 컨텍스트의 이점

- 1차 캐시
- 동일성 보장
- 변경 감지
- 지연 로딩
- 트랜잭션을 지원하는 쓰기 지연



### 영속성 컨텍스트2

- 1차 캐시 - 데이터 베이스 하나의 트랜잭션 안에서 유효
- 2차 캐시의 경우 애플리케이션 전체에서 공유



영속 엔티티의 동일성 보장

1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공



트랜잭션을 지원하는 쓰기 지연

변경감지

엔티티와 스냅샷을 비교하여 UPDATE SQL 을 생성하고 커밋하는 시점에 쿼리 발생



플러시

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영



엉속성 컨텍스트를 플러시하는 방법

- em.flush() 직접 호출
- 트랜잭션 커밋
- JPQL 쿼리 실행



### 플러시

JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유



주의사항

- 영속성 컨텍스를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요, 커밋 직전에만 동기화하면 됨



### 준영속 상태

- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함



준영속 상태로 만드는 방법

- em.detach(entity)
- em.clear
- em.close



### 정리

- 객체와 관계형 데이터베이스 매핑하기
- 영속성 컨텍스트
  - 이점
- 엔티티 라이프 사이클



## 엔티티 매핑



#### 객체와 테이블 매핑

@Entity, @Table

@Entity 가 붙은 클래스 JPA 관리하는 대상, 엔티티라 한다.

- 주의
  - 기본 생성자 ( public or protected )
  - final 클래스, enum, interface, ineer 클래스 사용 X
  - 저장할 필드에 final 사용 X
- 리플렉션 통한 다양한 기법때문에 제한이 있음



#### 데이터베이스 스키마 자동 생성

- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- DB 방언을 활용해 DB 에 맞는 적절한 DDL 생성
- 생성된 DDL 은 개발환경에서만 사용
- 운영에서는 적용 X, 따로 작성하거나 적절히 다듬은 후 사용



연관관계 공부할떄 테이블 DDL 확인하는 용도로만 사용하는게 좋을듯

프로덕션DB, 개발DB에서도 절대 사용하지 말고, 로컬 개발 환경에서됴

DB 형상관리 툴을 이용해 변경사항 반영하는게 편리할듯

 

#### 필드와 컬럼 매핑

#####  @Column 옵션

- unique DDL 생성기능, 런타임 영향 X

각 옵션들에 대해서 정리해야 하나?

DDL 생성 관련 옵션은 필요없고 런타임에 영향 끼치는것만 사용 및 정리하자



##### @Enumerated

- 순서 or 이름 데이터베이스에 저장



##### @Temporal

LocalDate, LocalDateTime 지원으로 불필요





#### 기본 키 매핑 

##### @Id

- 직접할당
- 자동 생성 @GeneratedValue : 기본키 생성을 DB에 위임
  - IDENTITY
  - AUTO: DB방언에 따라 자동 설정
  - SEQUENCE
    - SEQUENCE GENARATOR 활용
    - TABLE 전략 : 키 생성 전용 테이블 만들어 시퀀스 흉내내는 전략



권장하는 식별자 전략

- 기본 키 제약 조건: not null, unique, 변하면 안됨
- 미래까지 이 조건 만족하는 자연키 찾기 힘듬, 대리키를 사용하자.
- ex) 주민번호 적절하지 않음
- 권장: Long형 + 대체키 + 키 생성전략 사용



IDENTITY 전략 

- 기본키 생성을 DB에 위임
- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용
- MySQL의 AUTO_INCREMENT
- JPA 는 트랜잭션 커밋 시점에 INSERT SQL 실행
- AUTO_INCREMENT는 INSERT 후에 값을 알수 있음
- IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행 DB 식별자 조회
  - 쓰기 지연 전략 무의미..?
  - 버퍼링 해서 쓰기 전략 크게 성능에 영향 없다..?



시퀀스 전략 VS IDENTITY 전략 차이 비교하기

#### 요구사항 분석과 기본 매핑

JPA 어노테이션의 옵션중 DDL 시에 적용되는 사항 제약조건들을 사용하지 않더라도 엔티티만 보고 파악할 수 있도록 기록하는것도 좋다.

스프링 부트 설정에서 엔티티 필드를 컬럼 네임으로 변경하는 컨벤션 설정 찾아보기



##### 데이터 중심 설계의 문제점

- 객체 설계를 테이블 설계에 맞춘 방식
- 테이블의 외래키를 객체으 그대로 가져옴
- 객체 그래드 탐색이 불가능
- 참조가 없으므로 UML 잘못됨



