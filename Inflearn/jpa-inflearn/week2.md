# Week2



### 상품 도메인 개발

- 비지니스 로직이 도메인 모델에 있는 패턴
  - 상품의 재고 상태를 가지고 있는 도메인에서 변경

> :bulb: 
>
> 참고: 주문 서비스의 주문과 주문 취소 메서드를 보면 비즈니스 로직 대부분이 엔티티에 있다. 서비스 계층 은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다. 이처럼 엔티티가 비즈니스 로직을 가지고 객체 지 향의 특성을 적극 활용하는 것을 `도메인 모델 패턴`(http://martinfowler.com/eaaCatalog/ domainModel.html)이라 한다. 반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 의 비즈니스 로직을 처리하는 것을 `트랜잭션 스크립트 패턴`(http://martinfowler.com/eaaCatalog/ transactionScript.html)이라 한다.



### 주문 도메인 개발

- 생성 메서드

  - 생성자 호출 제한 및 제어
  - [정적 팩토리 메서드](https://it-mesung.tistory.com/184)

- 서비스 계층 테스트

  - [테스트 전략](https://cheese10yun.github.io/spring-guide-test-1/)

- 주문 검색

  - JPQL 으로 해결불가능한 부분있음 반드시 QueryDSL 써야함
  - 동적쿼리

  

### 웹 계층 개발



> :bulb:
>
> 참고: 폼 객체 vs 엔티티 직접 사용
>
> 요구사항이 정말 단순할 때는 폼 객체( MemberForm ) 없이 엔티티( Member )를 직접 등록과 수정 화면 에서 사용해도 된다. 하지만 화면 요구사항이 복잡해지기 시작하면, 엔티티에 화면을 처리하기 위한 기능이 점점 증가한다. 결과적으로 엔티티는 점점 화면에 종속적으로 변하고, 이렇게 화면 기능 때문에 지저분해진 엔티티는 결국 유지보수하기 어려워진다. **실무에서 엔티티는 핵심 비즈니스 로직만 가지고 있고, 화면을 위한 로직은 없어야 한다.** `화면이나 API에 맞 는 폼 객체나 DTO`를 사용하자. 그래서 화면이나 API 요구사항을 이것들로 처리하고, 엔티티는 최대한 순수 하게 유지하자

<br>

##### `준영속 엔티티`

 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다. (여기서는 itemService.saveItem(book) 에서 수정을 시도하는 Book 객체다. Book 객체는 이미 DB 에 한번 저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준 영속 엔티티로 볼 수 있다.) 준영속 엔티티를 수정하는 2가지 방법 변경 감지 기능 사용 병합( merge ) 사용

<br>

> :bulb:
>
> 참고: 실무에서는 보통 업데이트 기능이 매우 제한적. 그런데 병합은 모든 필드를 변경해버리고, 데이터 가 없으면 null 로 업데이트 해버린다. 병합을 사용하면서 이 문제를 해결하려면, 변경 폼 화면에서 모든 데 이터를 항상 유지해야 한다. 실무에서는 보통 변경가능한 데이터만 노출하기 때문에, 병합을 사용하는 것이 오히려 번거롭다

<br>

##### :bulb: **엔티티를 변경할 때는 항상 변경 감지를 사용**

- 컨트롤러에서 어설프게 엔티티를 생성X
- 트랜잭션이 있는 서비스 계층에 식별자( id )와 변경할 데이터를 명확하게 전달
- (파라미터 or dto) 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경 
- 트랜잭션 커밋 시점에 변경 감지가 실행