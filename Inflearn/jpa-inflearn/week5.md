# Week5



### 프록시

- find() vs getRefernce
  - 데이터베이스를 통해서 엔티티 객체 조회 vs 프록시 객체 조회
- 객체의 참조를 보관
- 최초 호출시 한번만 초기화

- 원본 엔티티 상속
  - 영속성 컨텍스트에 엔티티가 있으면, em.reference() 를 호출해도 프록시가 아닌 엔티티를 반환


<br>

### 지연로딩 vs 즉시로딩

- 지연 로딩은 프록시를 통해 조회
- 즉시로딩은 프록시가 아닌 엔티티 조회, FetchType 이 즉시로딩이 옵션이 있는 연관관계 엔티티들을 조인



> :bulb: 
>
> - 지연 로딩만 사용 권장
> - 즉시 로딩은 조회 SQL 예상하기 어려움
> - 즉시 로딩은 JPQL 에서 N+1 문제 발생
> - 지연 로딩으로 설정하고, JPQL fecth 조인, 엔티티 그래프 활용

<br>

### 영속성 전이

> 특정 엔티티 영속시 연관 엔티티도 함께 영속화 원할때 쓰는 옵션
>
> 엔티티 간의 영속 라이프 사이클 관리



- ALL
- PERSIST
- REMOVE
- MERGE
- REFRESH
- DETACH

:bomb: **주의**

부모, 자식 엔티티에서 자식엔티티가 다른 엔티티에도 참조되고 있을때 자식 엔티티를 삭제하면 문제 발생 



#### 고아 객체

- 참조가 제거된 엔티티를 고아객체로 보고 삭제하는 기능
- CascaseTypeALL + orphanRemovel 옵션으로 라이프사이클 관리하면 유용

<br>

### 기본 값 타입

JPA 의 데이터 타입 분류 중 식별자 존재 유무 기준

- 엔티티 타입
- 값 타입



#### 값 타입

- 기본값 타입
- 임베디드 타입
  - 높은 응집도, 재사용
- 컬렉션 값 타입



#### **@AttributeOverride**

한 엔티티 안에서 같은 값 타입을 사용할 경우 이용되는 옵션



#### 값 타입 공유 참조

- 임베디드 값타입을 여러 엔티티 공유하면 사이드 이펙트 우려
- 불변 상태로 관리하고 제어하여 실수 방지



#### 값 타입 비교

- `동일성`은 인스턴스의 참조값 비교
- `동등성` 인스턴스의 값을 비교 equals()



### 값 타입 컬렉션

- 값 타입 하나 이상 저장할 때 사용
- @ElementCollection, @CollectionTable 사용
- 데이터베이스는 같은 테이블에 컬렉션을 저장할 수 없으므로 별도의 테이블이 필요



#### 제약사항

- 값 타입 컬렉션에 변경사항이 생기면, 주인 엔티티와 연관된 데이터 삭제 후 추가
- 값 타입 컬렉션 매핑하는 테이블 모든 컬럼 묶어서 기본키 구성해야 됨



#### 대안

- 값 타입 대신 일대다 관계 고려
- 영속성 전이 + 고아객체 옵션을 통해 값 타입 컬렉션처럼 사용





